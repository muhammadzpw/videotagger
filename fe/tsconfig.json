{
  "compilerOptions": {
    "baseUrl": ".", // "paths" option needs this "baseUrl" option
    // So we don't need to type "import xxx from "../../../../"".
    // Instead, we can type "import xxx from "@common/xxx"".
    // Must be in sync with webpack.common.js -> resolve -> alias & jest.config.js -> moduleNameMapper
    "paths": {
      "@common/*": [
        "src/common/*",
        "src/common/*/index.ts",
        "src/common/*/index.tsx"
      ],
      "@domain/*": [
        "src/domain/*",
        "src/domain/*/index.ts",
        "src/domain/*/index.tsx"
      ]
    },
    // "sourceMap" is needed for debugging purpose.
    // Without this, the mapping will still be generated from the JS file generated by TS compiler.
    // However, the JS file generated by TS compiler doesn't preserve the empty newline.
    // The empty newline is preserved inside mapping file produced by TS compiler (which is configured with this "sourceMap" key).
    // The mapping file from TS compiler will be used by webpack so when there's an error, we can debug it all the way to the .ts or .tsx file.
    "sourceMap": true,
    // "module" specifies module code generation. "esNext" will produce "import", "commonjs" will produce "require".
    // "esNext" is required for webpack's tree-shaking feature to work (tree-shaking will not work with "require" syntax).
    // Why "esNext" and nost just "es6"? Because we need `Dynamic Import` and it is only supported when '--module' flag is 'commonjs' or 'esNext'.
    // The weird thing: although "commonjs" doesn't complain 'Dynamic Import' syntax, it will not produce dynamically imported modules
    // when we build it using webpack, so using "commonjs" as the value for "module" option is not...an option (get it? haha)
    "module": "esNext",
    // Needed so we can import code from library which module can't be resolved using "moduleResolution": "classic".
    // Case in point: "@testing/react-library" and "apollo-boost"
    // If we don't want this, there are two options: use "module": "commonjs" OR use "exclude".
    // 1. "module": "commonjs" is not an option because it's not compatible with break tree-shaking.
    // 2. "exclude" such as "exclude": ["./src/**/*.test.tsx", "./src/**/*.test.ts"] is also not an option.
    //    It's OK if it's just for test file. Unfortunately, apollo-boost will surely be needed outside test file.
    // Therefore, we need to force module resolution to "node".
    // If you omit this option and your VSCode doesn't give warning, try restarting it.
    // Or try to compile it via CLI.
    "moduleResolution": "node",
    // So webpack can compile TypeScript optional chaining, we use ES2018 as target
    // https://stackoverflow.com/questions/58813176/webpack-cant-compile-ts-3-7-optional-chaining-nullish-coalescing
    "target": "es2018", // Specify the target code version of TS compiler output
    "jsx": "react", // what kind of JSX to be supported in .tsx files
    //strict: true === noImplicitAny, noImplicitThis, alwaysStrict, strictBindCallApply, strictNullChecks, strictFunctionTypes, strictPropertyInitialization.
    "strict": true,
    "noUnusedLocals": false, //To warn us with unused imports.
    "noUnusedParameters": false, //To warn us with unused parameters.
    "forceConsistentCasingInFileNames": true,
    "noImplicitReturns": true,
    "allowSyntheticDefaultImports": true, // Because lodash.debounce is exported using "export =" and it needs this flag to be true
    "lib": [
      "dom", // Needed so we can access "window" object.
      "es2018" // "A dynamic import call in ES5/ES3 requires the 'Promise' constructor.  Make sure you have a declaration for the 'Promise' constructor or include 'ES2015' in your `--lib` option.."
    ]
  },
  "include": ["./src/**/*"]
}
